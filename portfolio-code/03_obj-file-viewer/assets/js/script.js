/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assets/ts/script.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/assets/js/lib/minMatrixb.js":
/*!*****************************************!*\
  !*** ./src/assets/js/lib/minMatrixb.js ***!
  \*****************************************/
/*! exports provided: matIV, qtnIV, torus, sphere, cube, hsva */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matIV\", function() { return matIV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"qtnIV\", function() { return qtnIV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"torus\", function() { return torus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sphere\", function() { return sphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cube\", function() { return cube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsva\", function() { return hsva; });\n// ------------------------------------------------------------------------------------------------\n// minMatrixb.js\n// version 0.0.2\n// Copyright (c) doxas\n// ------------------------------------------------------------------------------------------------\n\nfunction matIV(){\n  this.create = function(){\n    return new Float32Array(16);\n  };\n  this.identity = function(dest){\n    dest[0]  = 1; dest[1]  = 0; dest[2]  = 0; dest[3]  = 0;\n    dest[4]  = 0; dest[5]  = 1; dest[6]  = 0; dest[7]  = 0;\n    dest[8]  = 0; dest[9]  = 0; dest[10] = 1; dest[11] = 0;\n    dest[12] = 0; dest[13] = 0; dest[14] = 0; dest[15] = 1;\n    return dest;\n  };\n  this.multiply = function(mat1, mat2, dest){\n    var a = mat1[0],  b = mat1[1],  c = mat1[2],  d = mat1[3],\n      e = mat1[4],  f = mat1[5],  g = mat1[6],  h = mat1[7],\n      i = mat1[8],  j = mat1[9],  k = mat1[10], l = mat1[11],\n      m = mat1[12], n = mat1[13], o = mat1[14], p = mat1[15],\n      A = mat2[0],  B = mat2[1],  C = mat2[2],  D = mat2[3],\n      E = mat2[4],  F = mat2[5],  G = mat2[6],  H = mat2[7],\n      I = mat2[8],  J = mat2[9],  K = mat2[10], L = mat2[11],\n      M = mat2[12], N = mat2[13], O = mat2[14], P = mat2[15];\n    dest[0] = A * a + B * e + C * i + D * m;\n    dest[1] = A * b + B * f + C * j + D * n;\n    dest[2] = A * c + B * g + C * k + D * o;\n    dest[3] = A * d + B * h + C * l + D * p;\n    dest[4] = E * a + F * e + G * i + H * m;\n    dest[5] = E * b + F * f + G * j + H * n;\n    dest[6] = E * c + F * g + G * k + H * o;\n    dest[7] = E * d + F * h + G * l + H * p;\n    dest[8] = I * a + J * e + K * i + L * m;\n    dest[9] = I * b + J * f + K * j + L * n;\n    dest[10] = I * c + J * g + K * k + L * o;\n    dest[11] = I * d + J * h + K * l + L * p;\n    dest[12] = M * a + N * e + O * i + P * m;\n    dest[13] = M * b + N * f + O * j + P * n;\n    dest[14] = M * c + N * g + O * k + P * o;\n    dest[15] = M * d + N * h + O * l + P * p;\n    return dest;\n  };\n  this.scale = function(mat, vec, dest){\n    dest[0]  = mat[0]  * vec[0];\n    dest[1]  = mat[1]  * vec[0];\n    dest[2]  = mat[2]  * vec[0];\n    dest[3]  = mat[3]  * vec[0];\n    dest[4]  = mat[4]  * vec[1];\n    dest[5]  = mat[5]  * vec[1];\n    dest[6]  = mat[6]  * vec[1];\n    dest[7]  = mat[7]  * vec[1];\n    dest[8]  = mat[8]  * vec[2];\n    dest[9]  = mat[9]  * vec[2];\n    dest[10] = mat[10] * vec[2];\n    dest[11] = mat[11] * vec[2];\n    dest[12] = mat[12];\n    dest[13] = mat[13];\n    dest[14] = mat[14];\n    dest[15] = mat[15];\n    return dest;\n  };\n  this.translate = function(mat, vec, dest){\n    dest[0] = mat[0]; dest[1] = mat[1]; dest[2]  = mat[2];  dest[3]  = mat[3];\n    dest[4] = mat[4]; dest[5] = mat[5]; dest[6]  = mat[6];  dest[7]  = mat[7];\n    dest[8] = mat[8]; dest[9] = mat[9]; dest[10] = mat[10]; dest[11] = mat[11];\n    dest[12] = mat[0] * vec[0] + mat[4] * vec[1] + mat[8]  * vec[2] + mat[12];\n    dest[13] = mat[1] * vec[0] + mat[5] * vec[1] + mat[9]  * vec[2] + mat[13];\n    dest[14] = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14];\n    dest[15] = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15];\n    return dest;\n  };\n  this.rotate = function(mat, angle, axis, dest){\n    var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n    if(!sq){return null;}\n    var a = axis[0], b = axis[1], c = axis[2];\n    if(sq != 1){sq = 1 / sq; a *= sq; b *= sq; c *= sq;}\n    var d = Math.sin(angle), e = Math.cos(angle), f = 1 - e,\n      g = mat[0],  h = mat[1], i = mat[2],  j = mat[3],\n      k = mat[4],  l = mat[5], m = mat[6],  n = mat[7],\n      o = mat[8],  p = mat[9], q = mat[10], r = mat[11],\n      s = a * a * f + e,\n      t = b * a * f + c * d,\n      u = c * a * f - b * d,\n      v = a * b * f - c * d,\n      w = b * b * f + e,\n      x = c * b * f + a * d,\n      y = a * c * f + b * d,\n      z = b * c * f - a * d,\n      A = c * c * f + e;\n    if(angle){\n      if(mat != dest){\n        dest[12] = mat[12]; dest[13] = mat[13];\n        dest[14] = mat[14]; dest[15] = mat[15];\n      }\n    } else {\n      dest = mat;\n    }\n    dest[0]  = g * s + k * t + o * u;\n    dest[1]  = h * s + l * t + p * u;\n    dest[2]  = i * s + m * t + q * u;\n    dest[3]  = j * s + n * t + r * u;\n    dest[4]  = g * v + k * w + o * x;\n    dest[5]  = h * v + l * w + p * x;\n    dest[6]  = i * v + m * w + q * x;\n    dest[7]  = j * v + n * w + r * x;\n    dest[8]  = g * y + k * z + o * A;\n    dest[9]  = h * y + l * z + p * A;\n    dest[10] = i * y + m * z + q * A;\n    dest[11] = j * y + n * z + r * A;\n    return dest;\n  };\n  this.lookAt = function(eye, center, up, dest){\n    var eyeX    = eye[0],    eyeY    = eye[1],    eyeZ    = eye[2],\n      upX     = up[0],     upY     = up[1],     upZ     = up[2],\n      centerX = center[0], centerY = center[1], centerZ = center[2];\n    if(eyeX == centerX && eyeY == centerY && eyeZ == centerZ){return this.identity(dest);}\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, l;\n    z0 = eyeX - center[0]; z1 = eyeY - center[1]; z2 = eyeZ - center[2];\n    l = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= l; z1 *= l; z2 *= l;\n    x0 = upY * z2 - upZ * z1;\n    x1 = upZ * z0 - upX * z2;\n    x2 = upX * z1 - upY * z0;\n    l = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if(!l){\n      x0 = 0; x1 = 0; x2 = 0;\n    } else {\n      l = 1 / l;\n      x0 *= l; x1 *= l; x2 *= l;\n    }\n    y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;\n    l = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if(!l){\n      y0 = 0; y1 = 0; y2 = 0;\n    } else {\n      l = 1 / l;\n      y0 *= l; y1 *= l; y2 *= l;\n    }\n    dest[0] = x0; dest[1] = y0; dest[2]  = z0; dest[3]  = 0;\n    dest[4] = x1; dest[5] = y1; dest[6]  = z1; dest[7]  = 0;\n    dest[8] = x2; dest[9] = y2; dest[10] = z2; dest[11] = 0;\n    dest[12] = -(x0 * eyeX + x1 * eyeY + x2 * eyeZ);\n    dest[13] = -(y0 * eyeX + y1 * eyeY + y2 * eyeZ);\n    dest[14] = -(z0 * eyeX + z1 * eyeY + z2 * eyeZ);\n    dest[15] = 1;\n    return dest;\n  };\n  this.perspective = function(fovy, aspect, near, far, dest){\n    var t = near * Math.tan(fovy * Math.PI / 360);\n    var r = t * aspect;\n    var a = r * 2, b = t * 2, c = far - near;\n    dest[0]  = near * 2 / a;\n    dest[1]  = 0;\n    dest[2]  = 0;\n    dest[3]  = 0;\n    dest[4]  = 0;\n    dest[5]  = near * 2 / b;\n    dest[6]  = 0;\n    dest[7]  = 0;\n    dest[8]  = 0;\n    dest[9]  = 0;\n    dest[10] = -(far + near) / c;\n    dest[11] = -1;\n    dest[12] = 0;\n    dest[13] = 0;\n    dest[14] = -(far * near * 2) / c;\n    dest[15] = 0;\n    return dest;\n  };\n  this.ortho = function(left, right, top, bottom, near, far, dest) {\n    var h = (right - left);\n    var v = (top - bottom);\n    var d = (far - near);\n    dest[0]  = 2 / h;\n    dest[1]  = 0;\n    dest[2]  = 0;\n    dest[3]  = 0;\n    dest[4]  = 0;\n    dest[5]  = 2 / v;\n    dest[6]  = 0;\n    dest[7]  = 0;\n    dest[8]  = 0;\n    dest[9]  = 0;\n    dest[10] = -2 / d;\n    dest[11] = 0;\n    dest[12] = -(left + right) / h;\n    dest[13] = -(top + bottom) / v;\n    dest[14] = -(far + near) / d;\n    dest[15] = 1;\n    return dest;\n  };\n  this.transpose = function(mat, dest){\n    dest[0]  = mat[0];  dest[1]  = mat[4];\n    dest[2]  = mat[8];  dest[3]  = mat[12];\n    dest[4]  = mat[1];  dest[5]  = mat[5];\n    dest[6]  = mat[9];  dest[7]  = mat[13];\n    dest[8]  = mat[2];  dest[9]  = mat[6];\n    dest[10] = mat[10]; dest[11] = mat[14];\n    dest[12] = mat[3];  dest[13] = mat[7];\n    dest[14] = mat[11]; dest[15] = mat[15];\n    return dest;\n  };\n  this.inverse = function(mat, dest){\n    var a = mat[0],  b = mat[1],  c = mat[2],  d = mat[3],\n      e = mat[4],  f = mat[5],  g = mat[6],  h = mat[7],\n      i = mat[8],  j = mat[9],  k = mat[10], l = mat[11],\n      m = mat[12], n = mat[13], o = mat[14], p = mat[15],\n      q = a * f - b * e, r = a * g - c * e,\n      s = a * h - d * e, t = b * g - c * f,\n      u = b * h - d * f, v = c * h - d * g,\n      w = i * n - j * m, x = i * o - k * m,\n      y = i * p - l * m, z = j * o - k * n,\n      A = j * p - l * n, B = k * p - l * o,\n      ivd = 1 / (q * B - r * A + s * z + t * y - u * x + v * w);\n    dest[0]  = ( f * B - g * A + h * z) * ivd;\n    dest[1]  = (-b * B + c * A - d * z) * ivd;\n    dest[2]  = ( n * v - o * u + p * t) * ivd;\n    dest[3]  = (-j * v + k * u - l * t) * ivd;\n    dest[4]  = (-e * B + g * y - h * x) * ivd;\n    dest[5]  = ( a * B - c * y + d * x) * ivd;\n    dest[6]  = (-m * v + o * s - p * r) * ivd;\n    dest[7]  = ( i * v - k * s + l * r) * ivd;\n    dest[8]  = ( e * A - f * y + h * w) * ivd;\n    dest[9]  = (-a * A + b * y - d * w) * ivd;\n    dest[10] = ( m * u - n * s + p * q) * ivd;\n    dest[11] = (-i * u + j * s - l * q) * ivd;\n    dest[12] = (-e * z + f * x - g * w) * ivd;\n    dest[13] = ( a * z - b * x + c * w) * ivd;\n    dest[14] = (-m * t + n * r - o * q) * ivd;\n    dest[15] = ( i * t - j * r + k * q) * ivd;\n    return dest;\n  };\n}\n\nfunction qtnIV(){\n  this.create = function(){\n    return new Float32Array(4);\n  };\n  this.identity = function(dest){\n    dest[0] = 0; dest[1] = 0; dest[2] = 0; dest[3] = 1;\n    return dest;\n  };\n  this.inverse = function(qtn, dest){\n    dest[0] = -qtn[0];\n    dest[1] = -qtn[1];\n    dest[2] = -qtn[2];\n    dest[3] =  qtn[3];\n    return dest;\n  };\n  this.normalize = function(dest){\n    var x = dest[0], y = dest[1], z = dest[2], w = dest[3];\n    var l = Math.sqrt(x * x + y * y + z * z + w * w);\n    if(l === 0){\n      dest[0] = 0;\n      dest[1] = 0;\n      dest[2] = 0;\n      dest[3] = 0;\n    }else{\n      l = 1 / l;\n      dest[0] = x * l;\n      dest[1] = y * l;\n      dest[2] = z * l;\n      dest[3] = w * l;\n    }\n    return dest;\n  };\n  this.multiply = function(qtn1, qtn2, dest){\n    var ax = qtn1[0], ay = qtn1[1], az = qtn1[2], aw = qtn1[3];\n    var bx = qtn2[0], by = qtn2[1], bz = qtn2[2], bw = qtn2[3];\n    dest[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dest[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dest[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dest[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dest;\n  };\n  this.rotate = function(angle, axis, dest){\n    var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n    if(!sq){return null;}\n    var a = axis[0], b = axis[1], c = axis[2];\n    if(sq != 1){sq = 1 / sq; a *= sq; b *= sq; c *= sq;}\n    var s = Math.sin(angle * 0.5);\n    dest[0] = a * s;\n    dest[1] = b * s;\n    dest[2] = c * s;\n    dest[3] = Math.cos(angle * 0.5);\n    return dest;\n  };\n  this.toVecIII = function(vec, qtn, dest){\n    var qp = this.create();\n    var qq = this.create();\n    var qr = this.create();\n    this.inverse(qtn, qr);\n    qp[0] = vec[0];\n    qp[1] = vec[1];\n    qp[2] = vec[2];\n    this.multiply(qr, qp, qq);\n    this.multiply(qq, qtn, qr);\n    dest[0] = qr[0];\n    dest[1] = qr[1];\n    dest[2] = qr[2];\n    return dest;\n  };\n  this.toMatIV = function(qtn, dest){\n    var x = qtn[0], y = qtn[1], z = qtn[2], w = qtn[3];\n    var x2 = x + x, y2 = y + y, z2 = z + z;\n    var xx = x * x2, xy = x * y2, xz = x * z2;\n    var yy = y * y2, yz = y * z2, zz = z * z2;\n    var wx = w * x2, wy = w * y2, wz = w * z2;\n    dest[0]  = 1 - (yy + zz);\n    dest[1]  = xy - wz;\n    dest[2]  = xz + wy;\n    dest[3]  = 0;\n    dest[4]  = xy + wz;\n    dest[5]  = 1 - (xx + zz);\n    dest[6]  = yz - wx;\n    dest[7]  = 0;\n    dest[8]  = xz - wy;\n    dest[9]  = yz + wx;\n    dest[10] = 1 - (xx + yy);\n    dest[11] = 0;\n    dest[12] = 0;\n    dest[13] = 0;\n    dest[14] = 0;\n    dest[15] = 1;\n    return dest;\n  };\n  this.slerp = function(qtn1, qtn2, time, dest){\n    var ht = qtn1[0] * qtn2[0] + qtn1[1] * qtn2[1] + qtn1[2] * qtn2[2] + qtn1[3] * qtn2[3];\n    var hs = 1.0 - ht * ht;\n    if(hs <= 0.0){\n      dest[0] = qtn1[0];\n      dest[1] = qtn1[1];\n      dest[2] = qtn1[2];\n      dest[3] = qtn1[3];\n    }else{\n      hs = Math.sqrt(hs);\n      if(Math.abs(hs) < 0.0001){\n        dest[0] = (qtn1[0] * 0.5 + qtn2[0] * 0.5);\n        dest[1] = (qtn1[1] * 0.5 + qtn2[1] * 0.5);\n        dest[2] = (qtn1[2] * 0.5 + qtn2[2] * 0.5);\n        dest[3] = (qtn1[3] * 0.5 + qtn2[3] * 0.5);\n      }else{\n        var ph = Math.acos(ht);\n        var pt = ph * time;\n        var t0 = Math.sin(ph - pt) / hs;\n        var t1 = Math.sin(pt) / hs;\n        dest[0] = qtn1[0] * t0 + qtn2[0] * t1;\n        dest[1] = qtn1[1] * t0 + qtn2[1] * t1;\n        dest[2] = qtn1[2] * t0 + qtn2[2] * t1;\n        dest[3] = qtn1[3] * t0 + qtn2[3] * t1;\n      }\n    }\n    return dest;\n  };\n}\n\nfunction torus(row, column, irad, orad, color){\n  var pos = new Array(), nor = new Array(),\n    col = new Array(), st  = new Array(), idx = new Array();\n  for(var i = 0; i <= row; i++){\n    var r = Math.PI * 2 / row * i;\n    var rr = Math.cos(r);\n    var ry = Math.sin(r);\n    for(var ii = 0; ii <= column; ii++){\n      var tr = Math.PI * 2 / column * ii;\n      var tx = (rr * irad + orad) * Math.cos(tr);\n      var ty = ry * irad;\n      var tz = (rr * irad + orad) * Math.sin(tr);\n      var rx = rr * Math.cos(tr);\n      var rz = rr * Math.sin(tr);\n      if(color){\n        var tc = color;\n      }else{\n        tc = hsva(360 / column * ii, 1, 1, 1);\n      }\n      var rs = 1 / column * ii;\n      var rt = 1 / row * i + 0.5;\n      if(rt > 1.0){rt -= 1.0;}\n      rt = 1.0 - rt;\n      pos.push(tx, ty, tz);\n      nor.push(rx, ry, rz);\n      col.push(tc[0], tc[1], tc[2], tc[3]);\n      st.push(rs, rt);\n    }\n  }\n  for(i = 0; i < row; i++){\n    for(ii = 0; ii < column; ii++){\n      r = (column + 1) * i + ii;\n      idx.push(r, r + column + 1, r + 1);\n      idx.push(r + column + 1, r + column + 2, r + 1);\n    }\n  }\n  return {p : pos, n : nor, c : col, t : st, i : idx};\n}\n\nfunction sphere(row, column, rad, color){\n  var pos = new Array(), nor = new Array(),\n    col = new Array(), st  = new Array(), idx = new Array();\n  for(var i = 0; i <= row; i++){\n    var r = Math.PI / row * i;\n    var ry = Math.cos(r);\n    var rr = Math.sin(r);\n    for(var ii = 0; ii <= column; ii++){\n      var tr = Math.PI * 2 / column * ii;\n      var tx = rr * rad * Math.cos(tr);\n      var ty = ry * rad;\n      var tz = rr * rad * Math.sin(tr);\n      var rx = rr * Math.cos(tr);\n      var rz = rr * Math.sin(tr);\n      if(color){\n        var tc = color;\n      }else{\n        tc = hsva(360 / row * i, 1, 1, 1);\n      }\n      pos.push(tx, ty, tz);\n      nor.push(rx, ry, rz);\n      col.push(tc[0], tc[1], tc[2], tc[3]);\n      st.push(1 - 1 / column * ii, 1 / row * i);\n    }\n  }\n  r = 0;\n  for(i = 0; i < row; i++){\n    for(ii = 0; ii < column; ii++){\n      r = (column + 1) * i + ii;\n      idx.push(r, r + 1, r + column + 2);\n      idx.push(r, r + column + 2, r + column + 1);\n    }\n  }\n  return {p : pos, n : nor, c : col, t : st, i : idx};\n}\n\nfunction cube(side, color){\n  var hs = side * 0.5;\n  var pos = [\n    -hs, -hs,  hs,  hs, -hs,  hs,  hs,  hs,  hs, -hs,  hs,  hs,\n    -hs, -hs, -hs, -hs,  hs, -hs,  hs,  hs, -hs,  hs, -hs, -hs,\n    -hs,  hs, -hs, -hs,  hs,  hs,  hs,  hs,  hs,  hs,  hs, -hs,\n    -hs, -hs, -hs,  hs, -hs, -hs,  hs, -hs,  hs, -hs, -hs,  hs,\n    hs, -hs, -hs,  hs,  hs, -hs,  hs,  hs,  hs,  hs, -hs,  hs,\n    -hs, -hs, -hs, -hs, -hs,  hs, -hs,  hs,  hs, -hs,  hs, -hs\n  ];\n  var nor = [\n    -1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0, -1.0,  1.0,  1.0,\n    -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0, -1.0, -1.0,\n    -1.0,  1.0, -1.0, -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0, -1.0,\n    -1.0, -1.0, -1.0,  1.0, -1.0, -1.0,  1.0, -1.0,  1.0, -1.0, -1.0,  1.0,\n    1.0, -1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0, -1.0,  1.0,\n    -1.0, -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0, -1.0\n  ];\n  var col = new Array();\n  for(var i = 0; i < pos.length / 3; i++){\n    if(color){\n      var tc = color;\n    }else{\n      tc = hsva(360 / pos.length / 3 * i, 1, 1, 1);\n    }\n    col.push(tc[0], tc[1], tc[2], tc[3]);\n  }\n  var st = [\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0\n  ];\n  var idx = [\n    0,  1,  2,  0,  2,  3,\n    4,  5,  6,  4,  6,  7,\n    8,  9, 10,  8, 10, 11,\n    12, 13, 14, 12, 14, 15,\n    16, 17, 18, 16, 18, 19,\n    20, 21, 22, 20, 22, 23\n  ];\n  return {p : pos, n : nor, c : col, t : st, i : idx};\n}\n\nfunction hsva(h, s, v, a){\n  if(s > 1 || v > 1 || a > 1){return;}\n  var th = h % 360;\n  var i = Math.floor(th / 60);\n  var f = th / 60 - i;\n  var m = v * (1 - s);\n  var n = v * (1 - s * f);\n  var k = v * (1 - s * (1 - f));\n  var color = new Array();\n  if(!s > 0 && !s < 0){\n    color.push(v, v, v, a);\n  } else {\n    var r = new Array(v, n, m, m, k, v);\n    var g = new Array(k, v, v, n, m, m);\n    var b = new Array(m, m, k, v, v, n);\n    color.push(r[i], g[i], b[i], a);\n  }\n  return color;\n}\n\n\n//# sourceURL=webpack:///./src/assets/js/lib/minMatrixb.js?");

/***/ }),

/***/ "./src/assets/js/lib/objson.js":
/*!*************************************!*\
  !*** ./src/assets/js/lib/objson.js ***!
  \*************************************/
/*! exports provided: objsonConvert, objsonVertexData, vec3Normalize, faceNormal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"objsonConvert\", function() { return objsonConvert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"objsonVertexData\", function() { return objsonVertexData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3Normalize\", function() { return vec3Normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"faceNormal\", function() { return faceNormal; });\n// ------------------------------------------------------------------------------------------------\n// objson.js\n// version 0.0.1\n// Copyright (c) doxas\n// ------------------------------------------------------------------------------------------------\n\nfunction objsonConvert(source){\n  source = source.replace(/^#[\\x20-\\x7e]+\\s$/gm, '');\n  source = source.replace(/^g[\\x20-\\x7e]+\\s$/gm, '');\n  source = source.replace(/^g\\s$/gm, '');\n  // source = source.replace(/\\x20{2,}/gm, '\\x20');\n  source = source.replace(/^\\s/gm, '');\n  var rows = source.match(/[\\x20-\\x7e]+\\s/gm);\n  var i, j, k, l;\n  var a, b, c, d;\n  var len, dest, fNormal;\n  var pos = 0;\n  var nor = 0;\n  var tex = 0;\n  var position = [];\n  var normal   = [];\n  var texCoord = [];\n  var vertex   = [];\n  var index    = [];\n  var indices  = [];\n  for(i = 0, len = rows.length; i < len; i++){\n    switch(rows[i].substr(0, 2)){\n      case 'v ':\n        a = rows[i].match(/-?[\\d\\.]+(e(?=-)?|e(?=\\+)?)?[-\\+\\d\\.]*/g);\n        // for(var i = 0; i <= a.length; i++){\n        //   if(a[i].substr(-3, 1) == '-'){\n        //     var numBase = a[i].slice(0, -3);\n        //     var numPow = a[i].substr(-2);\n        //     a[i] = numBase * Math.pow(0.1, numPow);\n        //   }\n        // }\n        if(vertex[pos] == null){\n          vertex[pos] = new objsonVertexData();\n          vertex[pos].faceIndex = [];\n        }\n        vertex[pos].position = [a[0], a[1], a[2]];\n        pos++;\n        break;\n      case 'vn':\n        a = rows[i].match(/-?[\\d\\.]+(e(?=-)?|e(?=\\+)?)?[-\\+\\d\\.]*/g);\n        if(vertex[nor] == null){\n          vertex[nor] = new objsonVertexData();\n          vertex[nor].faceIndex = [];\n        }\n        vertex[nor].normal = [a[0], a[1], a[2]];\n        nor++;\n        break;\n      case 'vt':\n        a = rows[i].match(/-?[\\d\\.]+(e(?=-)?|e(?=\\+)?)?[-\\+\\d\\.]*/g);\n        if(vertex[tex] == null){\n          vertex[tex] = new objsonVertexData();\n          vertex[tex].faceIndex = [];\n        }\n        vertex[tex].texCoord = [a[0], a[1]];\n        tex++;\n        break;\n      case 'f ':\n        a = rows[i].match(/[\\d\\/]+/g);\n        index.push(a[0], a[1], a[2]);\n        if(a.length > 3){\n          index.push(a[2], a[3], a[0]);\n        }\n        break;\n      default :\n        break;\n    }\n  }\n  if(nor === 0){\n    j = index.length / 3;\n    fNormal = new Array(j);\n    for(i = 0; i < j; i++){\n      a = index[i * 3    ].split(/\\//);\n      b = index[i * 3 + 1].split(/\\//);\n      c = index[i * 3 + 2].split(/\\//);\n      fNormal[i] = faceNormal(vertex[a[0] - 1].position, vertex[b[0] - 1].position, vertex[c[0] - 1].position);\n      vertex[a[0] - 1].faceIndex.push(i);\n      vertex[b[0] - 1].faceIndex.push(i);\n      vertex[c[0] - 1].faceIndex.push(i);\n    }\n    for(i = 0; i < pos; i++){\n      a = [0.0, 0.0, 0.0];\n      b = vertex[i].faceIndex;\n      k = b.length;\n      for(j = 0; j < k; j++){\n        a[0] += parseFloat(fNormal[b[j]][0]);\n        a[1] += parseFloat(fNormal[b[j]][1]);\n        a[2] += parseFloat(fNormal[b[j]][2]);\n      }\n      vertex[i].normal = vec3Normalize(a);\n    }\n  }\n  for(i = 0, len = index.length; i < len; i++){\n    j = Math.floor(i / 3);\n    a = index[i].split(/\\//);\n    k = a[0] - 1;\n    if(indices[k] == null){\n      indices[k] = new objsonVertexData();\n      indices[k].position = k;\n    }\n    if(a[2] != null){\n      if(a[2] !== ''){\n        if(indices[k].normal == null){\n          indices[k].normal = a[2] - 1;\n        }else{\n          if(indices[k].normal !== a[2] - 1){\n            indices[pos] = new objsonVertexData();\n            indices[pos].position = k;\n            indices[pos].normal = a[2] - 1;\n            k = pos;\n            pos++;\n          }\n        }\n      }\n    }\n    if(a[1] != null){\n      if(a[1] !== ''){\n        if(indices[k].texCoord == null){\n          indices[k].texCoord = a[1] - 1;\n        }else{\n          if(indices[k].texCoord !== a[1] - 1){\n            indices[pos] = new objsonVertexData();\n            indices[pos].position = a[0] - 1;\n            if(a[2] != null){\n              if(a[2] !== ''){\n                indices[pos].normal = a[2] - 1;\n              }\n            }\n            indices[pos].texCoord = a[1] - 1;\n            k = pos;\n            pos++;\n          }\n        }\n      }\n    }\n    index[i] = k;\n  }\n  for(i = 0, len = indices.length; i < len; i++){\n    a = indices[i];\n    b = []; c = []; d = [];\n    if(a != null){\n      k = a.position;\n      b = vertex[k].position;\n      position[i * 3]     = b[0];\n      position[i * 3 + 1] = b[1];\n      position[i * 3 + 2] = b[2];\n      if(nor > 0){k = a.normal;}\n      c = vertex[k].normal;\n      normal[i * 3]     = c[0];\n      normal[i * 3 + 1] = c[1];\n      normal[i * 3 + 2] = c[2];\n      if(tex > 0){\n        k = a.texCoord;\n        d = vertex[k].texCoord;\n        texCoord[i * 2]     = d[0];\n        texCoord[i * 2 + 1] = d[1];\n      }\n    }else{\n      b = vertex[i].position;\n      position[i * 3]     = b[0];\n      position[i * 3 + 1] = b[1];\n      position[i * 3 + 2] = b[2];\n      c = vertex[i].normal;\n      normal[i * 3]     = c[0];\n      normal[i * 3 + 1] = c[1];\n      normal[i * 3 + 2] = c[2];\n      if(tex > 0){\n        d = vertex[i].texCoord;\n        texCoord[i * 2]     = d[0];\n        texCoord[i * 2 + 1] = d[1];\n      }\n    }\n  }\n  dest = '{';\n  dest += '\"vertex\":' + indices.length;\n  dest += ',\"face\":' + index.length / 3;\n  dest += ',\"position\":[' + position.join(',') + ']';\n  dest += ',\"normal\":[' + normal.join(',') + ']';\n  if(tex > 0){dest += ',\"texCoord\":[' + texCoord.join(',') + ']';}\n  dest += ',\"index\":[' + index.join(',') + ']';\n  dest += '}';\n  return dest;\n}\n\nfunction objsonVertexData(){\n  this.position = null;\n  this.normal   = null;\n  this.texCoord = null;\n  this.faceIndex = null;\n}\n\nfunction vec3Normalize(v, d){\n  var e, dig;\n  var n = [0.0, 0.0, 0.0];\n  var l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  if(l > 0){\n    if(!d){dig = 5;}else{dig = d;}\n    e = 1.0 / l;\n    n[0] = (v[0] * e).toFixed(dig);\n    n[1] = (v[1] * e).toFixed(dig);\n    n[2] = (v[2] * e).toFixed(dig);\n  }\n  return n;\n}\n\nfunction faceNormal(v0, v1, v2){\n  var n = [];\n  var vec1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];\n  var vec2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];\n  n[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];\n  n[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];\n  n[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];\n  return vec3Normalize(n);\n}\n\n\n//# sourceURL=webpack:///./src/assets/js/lib/objson.js?");

/***/ }),

/***/ "./src/assets/ts/script.ts":
/*!*********************************!*\
  !*** ./src/assets/ts/script.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar minMatrixb_js_1 = __webpack_require__(/*! ../js/lib/minMatrixb.js */ \"./src/assets/js/lib/minMatrixb.js\");\n\nvar objson_js_1 = __webpack_require__(/*! ../js/lib/objson.js */ \"./src/assets/js/lib/objson.js\");\n\n(function () {\n  var jsStart = document.getElementById('js-Start');\n  var jsStartButton = document.getElementById('js-Start_Button');\n  var jsForm = document.getElementById('js-Form');\n  var jsFormButton = document.getElementById('js-Form_Button');\n  jsStartButton.addEventListener('click', function () {\n    jsStart.classList.add('idx-Start-Hidden');\n    jsForm.classList.remove('st-Form-Hidden');\n  }, false);\n  /* ---------------------------------------------------------------------------\n    VARIABLE\n  ---------------------------------------------------------------------------- */\n\n  var canvas;\n  var canvasWidth;\n  var canvasHeight;\n  var gl;\n  var obj;\n  var position;\n  var normal;\n  var texCoord;\n  var texCoordFix = [];\n  var index;\n  var indexLength;\n  var bufferList;\n  var texture;\n  var textureSrc;\n  var textureUnit = 0;\n  var aLocation = [];\n  var aStride = [];\n  var uLocation = [];\n  var eyePosition;\n  var skyDirection;\n  var lightDirection;\n  var skyColor;\n  var groundColor;\n  var time;\n  var startTime;\n  var count;\n  var objFlag = false;\n  var imgFlag = false;\n  /* ---------------------------------------------------------------------------\n    VARIABLE matrix\n  ---------------------------------------------------------------------------- */\n\n  var m4;\n  var mMatrix;\n  var vMatrix;\n  var pMatrix;\n  var vpMatrix;\n  var mvpMatrix;\n  var invMatrix;\n  var norMatrix;\n  /* ---------------------------------------------------------------------------\n    VARIABLE camera\n  ---------------------------------------------------------------------------- */\n\n  var cameraDistance = 500.0;\n  var cameraPosition = [0.0, 0.0, cameraDistance];\n  var centerPosition = [0.0, 0.0, 0.0];\n  var cameraUpDirection = [0.0, 1.0, 0.0];\n  var dCameraPosition = [0.0, 0.0, cameraDistance];\n  var dCenterPosition = [0.0, 0.0, 0.0];\n  var dCameraUpDirection = [0.0, 1.0, 0.0];\n  var cameraRotateX = 0.0;\n  var cameraRotateY = 0.0;\n  var cameraScale = 0.0;\n  var clickWhile = false;\n  var startPosition = [];\n  var endPosition = [];\n  var qt4 = new minMatrixb_js_1.qtnIV();\n  var qt = qt4.identity(qt4.create());\n  var qtx = qt4.identity(qt4.create());\n  var qty = qt4.identity(qt4.create());\n  window.addEventListener('load', function () {\n    canvas = document.getElementById('screen');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    gl = canvas.getContext('webgl');\n    canvas.addEventListener('mousedown', mouseInteractionStart, false);\n    canvas.addEventListener('mousemove', mouseInteractionMove, false);\n    canvas.addEventListener('mouseup', mouseInteractionEnd, false);\n    canvas.addEventListener('wheel', wheelScroll, false);\n    var program = createNewProgram(createNewShader('main_vs'), createNewShader('main_fs'));\n    aLocation[0] = gl.getAttribLocation(program, 'position');\n    aLocation[1] = gl.getAttribLocation(program, 'normal');\n    aLocation[2] = gl.getAttribLocation(program, 'texCoord');\n    aStride[0] = 3;\n    aStride[1] = 3;\n    aStride[2] = 2;\n    uLocation[0] = gl.getUniformLocation(program, 'mMatrix');\n    uLocation[1] = gl.getUniformLocation(program, 'mvpMatrix');\n    uLocation[2] = gl.getUniformLocation(program, 'invMatrix');\n    uLocation[3] = gl.getUniformLocation(program, 'norMatrix');\n    uLocation[4] = gl.getUniformLocation(program, 'textureUnit');\n    uLocation[5] = gl.getUniformLocation(program, 'skyDirection');\n    uLocation[6] = gl.getUniformLocation(program, 'lightDirection');\n    uLocation[7] = gl.getUniformLocation(program, 'eyePosition');\n    uLocation[8] = gl.getUniformLocation(program, 'skyColor');\n    uLocation[9] = gl.getUniformLocation(program, 'groudColor');\n    var form;\n    form = document.forms.configForm;\n    form.objFormInput.addEventListener('change', function (eve) {\n      var formResult = eve.target.files[0];\n      var fileReader = new FileReader();\n      fileReader.readAsText(formResult);\n      fileReader.addEventListener('load', function () {\n        console.log(objson_js_1.objsonConvert(fileReader.result));\n        obj = JSON.parse(objson_js_1.objsonConvert(fileReader.result));\n        objFlag = true;\n\n        for (var i = 0; i < obj.texCoord.length; i++) {\n          if (i % 2 === 0) {\n            texCoordFix[i] = obj.texCoord[i];\n          } else {\n            obj.texCoord[i] = 1 - obj.texCoord[i];\n            texCoordFix[i] = obj.texCoord[i];\n          }\n        }\n\n        console.log(obj.texCoord);\n        console.log(texCoordFix);\n      });\n    });\n    form.imgFormInput.addEventListener('change', function (eve) {\n      var formResult = eve.target.files[0];\n      var img = new Image();\n      img.addEventListener('load', function () {\n        texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n      }, false);\n      URL.revokeObjectURL(img.src);\n      img.src = URL.createObjectURL(formResult);\n      imgFlag = true;\n    });\n    jsFormButton.addEventListener('click', function () {\n      if (objFlag === true && imgFlag === true) {\n        initialize();\n        jsForm.classList.add('st-Form-Hidden');\n      }\n    }, false);\n  }, false); // const loadTexture = () => {\n  //   let img = new Image();\n  //   img.addEventListener('load', () => {\n  //     texture = gl.createTexture();\n  //     gl.bindTexture(gl.TEXTURE_2D, texture);\n  //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n  //     gl.generateMipmap(gl.TEXTURE_2D);\n  //     gl.bindTexture(gl.TEXTURE_2D, null);\n  //   }, false);\n  //   img.src = textureSrc;\n  //   initialize();\n  // };\n\n  var initialize = function initialize() {\n    position = createNewVbo(obj.position);\n    normal = createNewVbo(obj.normal);\n    texCoord = createNewVbo(texCoordFix);\n    index = createNewIbo(obj.index);\n    indexLength = obj.index.length;\n    bufferList = [position, normal, texCoord];\n    m4 = new minMatrixb_js_1.matIV();\n    mMatrix = m4.identity(m4.create());\n    vMatrix = m4.identity(m4.create());\n    pMatrix = m4.identity(m4.create());\n    vpMatrix = m4.identity(m4.create());\n    mvpMatrix = m4.identity(m4.create());\n    invMatrix = m4.identity(m4.create());\n    norMatrix = m4.identity(m4.create());\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LEQUAL);\n    gl.enable(gl.CULL_FACE);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    eyePosition = [0.0, 0.0, 20.0];\n    skyDirection = [0.0, 1.0, 0.0];\n    lightDirection = [-0.55, 0.55, 0.55];\n    skyColor = [0.828, 0.864, 0.88, 1.0];\n    groundColor = [0.5, 0.5, 0.5, 1.0];\n    time = 0;\n    startTime = Date.now();\n    count = 0;\n    render();\n  };\n\n  var render = function render() {\n    count++;\n    setNewAttribute(bufferList, aLocation, aStride);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index);\n    canvas.width = canvasWidth = window.innerWidth;\n    canvas.height = canvasHeight = window.innerHeight;\n    gl.viewport(0, 0, canvasWidth, canvasHeight);\n    var cameraAspect = canvasWidth / canvasHeight;\n    gl.clearColor(0.828, 0.864, 0.88, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    cameraUpdate();\n    m4.lookAt(cameraPosition, centerPosition, cameraUpDirection, vMatrix);\n    m4.perspective(45, cameraAspect, 0.1, cameraDistance * 2.0, pMatrix);\n    m4.multiply(pMatrix, vMatrix, vpMatrix);\n    time = (Date.now() - startTime) / 1000;\n    m4.identity(mMatrix);\n    m4.translate(mMatrix, [0.0, -5.0, 0.0], mMatrix); // m4.rotate(mMatrix, Math.PI * 0.5, [0.0, -1.0, 0.0625], mMatrix);\n\n    m4.rotate(mMatrix, Math.PI * 0.5, [0.0, -1.0, 0], mMatrix);\n    m4.rotate(mMatrix, time * 0.125, [0.0, -1.0, 0.0], mMatrix);\n    m4.multiply(vpMatrix, mMatrix, mvpMatrix);\n    m4.inverse(mMatrix, invMatrix);\n    m4.transpose(mMatrix, norMatrix);\n    m4.inverse(norMatrix, norMatrix);\n    gl.uniformMatrix4fv(uLocation[0], false, mMatrix);\n    gl.uniformMatrix4fv(uLocation[1], false, mvpMatrix);\n    gl.uniformMatrix4fv(uLocation[2], false, invMatrix);\n    gl.uniformMatrix4fv(uLocation[3], false, norMatrix);\n    gl.uniform1i(uLocation[4], textureUnit);\n    gl.uniform3fv(uLocation[5], skyDirection);\n    gl.uniform3fv(uLocation[6], lightDirection);\n    gl.uniform3fv(uLocation[7], eyePosition);\n    gl.uniform4fv(uLocation[8], skyColor);\n    gl.uniform4fv(uLocation[9], groundColor);\n    gl.drawElements(gl.TRIANGLES, indexLength, gl.UNSIGNED_SHORT, 0);\n    requestAnimationFrame(render);\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION loadObj\n  ---------------------------------------------------------------------------- */\n  // const loadObj = (file: string): void => {\n  //   let x: any = new XMLHttpRequest();\n  //   x.open('GET', file);\n  //   x.onreadystatechange = function() {\n  //     if (x.readyState === 4) {\n  //       obj = JSON.parse(objsonConvert(x.responseText));\n  //       initialize();\n  //       // loadTexture();\n  //     }\n  //   };\n  //   x.send();\n  // };\n\n  /* ---------------------------------------------------------------------------\n    FUNCTION loadTexture\n  ---------------------------------------------------------------------------- */\n  // const loadTexture = () => {\n  //   let image: any = new Image();\n  //   image.addEventListener(\n  //     'load',\n  //     () => {\n  //       texture = gl.createTexture();\n  //       gl.bindTexture(gl.TEXTURE_2D, texture);\n  //       gl.texImage2D(\n  //         gl.TEXTURE_2D,\n  //         0,\n  //         gl.RGBA,\n  //         gl.RGBA,\n  //         gl.UNSIGNED_BYTE,\n  //         image\n  //       );\n  //       gl.generateMipmap(gl.TEXTURE_2D);\n  //       gl.bindTexture(gl.TEXTURE_2D, null);\n  //       initialize();\n  //     },\n  //     false\n  //   );\n  //   image.src = 'image/Dolphin_BaseColor.png';\n  // };\n\n  /* ---------------------------------------------------------------------------\n    FUNCTION createNewShader\n  ---------------------------------------------------------------------------- */\n\n\n  var createNewShader = function createNewShader(id) {\n    var shader;\n    var scriptElement = document.getElementById(id);\n\n    if (!scriptElement) {\n      return;\n    }\n\n    switch (scriptElement.type) {\n      case 'x-shader/x-vertex':\n        shader = gl.createShader(gl.VERTEX_SHADER);\n        break;\n\n      case 'x-shader/x-fragment':\n        shader = gl.createShader(gl.FRAGMENT_SHADER);\n        break;\n\n      default:\n        return;\n    }\n\n    gl.shaderSource(shader, scriptElement.innerText);\n    gl.compileShader(shader);\n\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      return shader;\n    } else {\n      console.log(gl.getShaderInfoLog(shader));\n    }\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION createNewProgram\n  ---------------------------------------------------------------------------- */\n\n\n  var createNewProgram = function createNewProgram(vs, fs) {\n    var program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      gl.useProgram(program);\n      return program;\n    } else {\n      return null;\n    }\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION setNewAttribute\n  ---------------------------------------------------------------------------- */\n\n\n  var setNewAttribute = function setNewAttribute(vbo, aLocation, aStride) {\n    for (var i in vbo) {\n      // バッファをバインドする\n      gl.bindBuffer(gl.ARRAY_BUFFER, vbo[i]); // attributeLocationを有効にする\n\n      gl.enableVertexAttribArray(aLocation[i]); // attributeLocationを通知し登録する\n\n      gl.vertexAttribPointer(aLocation[i], aStride[i], gl.FLOAT, false, 0, 0);\n    }\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION createNewVbo\n  ---------------------------------------------------------------------------- */\n\n\n  var createNewVbo = function createNewVbo(data) {\n    // バッファオブジェクトの生成\n    var vbo = gl.createBuffer(); // バッファをバインドする\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo); // バッファにデータをセット\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW); // バッファのバインドを無効化\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null); // 生成した VBO を返す\n\n    return vbo;\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION createNewIbo\n  ---------------------------------------------------------------------------- */\n\n\n  var createNewIbo = function createNewIbo(data) {\n    // バッファオブジェクトの生成\n    var ibo = gl.createBuffer(); // バッファをバインドする\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); // バッファにデータをセット\n\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW); // gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);\n    // バッファのバインドを無効化\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); // 生成した IBO を返す\n\n    return ibo;\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION mouseInteractionStart\n  ---------------------------------------------------------------------------- */\n\n\n  var mouseInteractionStart = function mouseInteractionStart(eve) {\n    clickWhile = true;\n    startPosition = [eve.pageX, eve.pageY];\n    eve.preventDefault();\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION mouseInteractionMove\n  ---------------------------------------------------------------------------- */\n\n\n  var mouseInteractionMove = function mouseInteractionMove(eve) {\n    if (!clickWhile) {\n      return;\n    }\n\n    var w = canvas.width;\n    var h = canvas.height;\n    var s = 1.0 / Math.min(w, h);\n    endPosition = [eve.pageX - startPosition[0], eve.pageY - startPosition[1]];\n    startPosition = [eve.pageX, eve.pageY];\n\n    switch (eve.buttons) {\n      case 1:\n        cameraRotateX += endPosition[0] * s;\n        cameraRotateY += endPosition[1] * s;\n        cameraRotateX = cameraRotateX % 1.0;\n        cameraRotateY = Math.min(Math.max(cameraRotateY % 1.0, -0.25), 0.25);\n        break;\n    }\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION mouseInteractionEnd\n  ---------------------------------------------------------------------------- */\n\n\n  var mouseInteractionEnd = function mouseInteractionEnd() {\n    clickWhile = false;\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION wheelScroll\n  ---------------------------------------------------------------------------- */\n\n\n  var wheelScroll = function wheelScroll(eve) {\n    var w = eve.wheelDelta;\n\n    if (w > 0) {\n      cameraScale = 0.8;\n    } else if (w < 0) {\n      cameraScale = -0.8;\n    }\n  };\n  /* ---------------------------------------------------------------------------\n    FUNCTION cameraUpdate\n  ---------------------------------------------------------------------------- */\n\n\n  var cameraUpdate = function cameraUpdate() {\n    var v = [1.0, 0.0, 0.0];\n    cameraScale *= 0.75;\n    cameraDistance += cameraScale;\n    cameraDistance = Math.min(Math.max(cameraDistance, 5.0), 20.0);\n    dCameraPosition[2] = cameraDistance;\n    qt4.identity(qt);\n    qt4.identity(qtx);\n    qt4.identity(qty);\n    qt4.rotate(cameraRotateX * Math.PI * 2, [0.0, 1.0, 0.0], qtx);\n    qt4.toVecIII(v, qtx, v);\n    qt4.rotate(cameraRotateY * Math.PI * 2, v, qty);\n    qt4.multiply(qtx, qty, qt);\n    qt4.toVecIII(dCameraPosition, qt, cameraPosition);\n    qt4.toVecIII(dCameraUpDirection, qt, cameraUpDirection);\n  };\n})();\n\n//# sourceURL=webpack:///./src/assets/ts/script.ts?");

/***/ })

/******/ });