/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assets/js/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/assets/js/lib/minMatrixb.js":
/*!*****************************************!*\
  !*** ./src/assets/js/lib/minMatrixb.js ***!
  \*****************************************/
/*! exports provided: matIV, qtnIV, torus, sphere, cube, hsva */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matIV\", function() { return matIV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"qtnIV\", function() { return qtnIV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"torus\", function() { return torus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sphere\", function() { return sphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cube\", function() { return cube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsva\", function() { return hsva; });\n// ------------------------------------------------------------------------------------------------\n// minMatrixb.js\n// version 0.0.2\n// Copyright (c) doxas\n// ------------------------------------------------------------------------------------------------\nfunction matIV() {\n  this.create = function () {\n    return new Float32Array(16);\n  };\n\n  this.identity = function (dest) {\n    dest[0] = 1;\n    dest[1] = 0;\n    dest[2] = 0;\n    dest[3] = 0;\n    dest[4] = 0;\n    dest[5] = 1;\n    dest[6] = 0;\n    dest[7] = 0;\n    dest[8] = 0;\n    dest[9] = 0;\n    dest[10] = 1;\n    dest[11] = 0;\n    dest[12] = 0;\n    dest[13] = 0;\n    dest[14] = 0;\n    dest[15] = 1;\n    return dest;\n  };\n\n  this.multiply = function (mat1, mat2, dest) {\n    var a = mat1[0],\n        b = mat1[1],\n        c = mat1[2],\n        d = mat1[3],\n        e = mat1[4],\n        f = mat1[5],\n        g = mat1[6],\n        h = mat1[7],\n        i = mat1[8],\n        j = mat1[9],\n        k = mat1[10],\n        l = mat1[11],\n        m = mat1[12],\n        n = mat1[13],\n        o = mat1[14],\n        p = mat1[15],\n        A = mat2[0],\n        B = mat2[1],\n        C = mat2[2],\n        D = mat2[3],\n        E = mat2[4],\n        F = mat2[5],\n        G = mat2[6],\n        H = mat2[7],\n        I = mat2[8],\n        J = mat2[9],\n        K = mat2[10],\n        L = mat2[11],\n        M = mat2[12],\n        N = mat2[13],\n        O = mat2[14],\n        P = mat2[15];\n    dest[0] = A * a + B * e + C * i + D * m;\n    dest[1] = A * b + B * f + C * j + D * n;\n    dest[2] = A * c + B * g + C * k + D * o;\n    dest[3] = A * d + B * h + C * l + D * p;\n    dest[4] = E * a + F * e + G * i + H * m;\n    dest[5] = E * b + F * f + G * j + H * n;\n    dest[6] = E * c + F * g + G * k + H * o;\n    dest[7] = E * d + F * h + G * l + H * p;\n    dest[8] = I * a + J * e + K * i + L * m;\n    dest[9] = I * b + J * f + K * j + L * n;\n    dest[10] = I * c + J * g + K * k + L * o;\n    dest[11] = I * d + J * h + K * l + L * p;\n    dest[12] = M * a + N * e + O * i + P * m;\n    dest[13] = M * b + N * f + O * j + P * n;\n    dest[14] = M * c + N * g + O * k + P * o;\n    dest[15] = M * d + N * h + O * l + P * p;\n    return dest;\n  };\n\n  this.scale = function (mat, vec, dest) {\n    dest[0] = mat[0] * vec[0];\n    dest[1] = mat[1] * vec[0];\n    dest[2] = mat[2] * vec[0];\n    dest[3] = mat[3] * vec[0];\n    dest[4] = mat[4] * vec[1];\n    dest[5] = mat[5] * vec[1];\n    dest[6] = mat[6] * vec[1];\n    dest[7] = mat[7] * vec[1];\n    dest[8] = mat[8] * vec[2];\n    dest[9] = mat[9] * vec[2];\n    dest[10] = mat[10] * vec[2];\n    dest[11] = mat[11] * vec[2];\n    dest[12] = mat[12];\n    dest[13] = mat[13];\n    dest[14] = mat[14];\n    dest[15] = mat[15];\n    return dest;\n  };\n\n  this.translate = function (mat, vec, dest) {\n    dest[0] = mat[0];\n    dest[1] = mat[1];\n    dest[2] = mat[2];\n    dest[3] = mat[3];\n    dest[4] = mat[4];\n    dest[5] = mat[5];\n    dest[6] = mat[6];\n    dest[7] = mat[7];\n    dest[8] = mat[8];\n    dest[9] = mat[9];\n    dest[10] = mat[10];\n    dest[11] = mat[11];\n    dest[12] = mat[0] * vec[0] + mat[4] * vec[1] + mat[8] * vec[2] + mat[12];\n    dest[13] = mat[1] * vec[0] + mat[5] * vec[1] + mat[9] * vec[2] + mat[13];\n    dest[14] = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14];\n    dest[15] = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15];\n    return dest;\n  };\n\n  this.rotate = function (mat, angle, axis, dest) {\n    var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n\n    if (!sq) {\n      return null;\n    }\n\n    var a = axis[0],\n        b = axis[1],\n        c = axis[2];\n\n    if (sq != 1) {\n      sq = 1 / sq;\n      a *= sq;\n      b *= sq;\n      c *= sq;\n    }\n\n    var d = Math.sin(angle),\n        e = Math.cos(angle),\n        f = 1 - e,\n        g = mat[0],\n        h = mat[1],\n        i = mat[2],\n        j = mat[3],\n        k = mat[4],\n        l = mat[5],\n        m = mat[6],\n        n = mat[7],\n        o = mat[8],\n        p = mat[9],\n        q = mat[10],\n        r = mat[11],\n        s = a * a * f + e,\n        t = b * a * f + c * d,\n        u = c * a * f - b * d,\n        v = a * b * f - c * d,\n        w = b * b * f + e,\n        x = c * b * f + a * d,\n        y = a * c * f + b * d,\n        z = b * c * f - a * d,\n        A = c * c * f + e;\n\n    if (angle) {\n      if (mat != dest) {\n        dest[12] = mat[12];\n        dest[13] = mat[13];\n        dest[14] = mat[14];\n        dest[15] = mat[15];\n      }\n    } else {\n      dest = mat;\n    }\n\n    dest[0] = g * s + k * t + o * u;\n    dest[1] = h * s + l * t + p * u;\n    dest[2] = i * s + m * t + q * u;\n    dest[3] = j * s + n * t + r * u;\n    dest[4] = g * v + k * w + o * x;\n    dest[5] = h * v + l * w + p * x;\n    dest[6] = i * v + m * w + q * x;\n    dest[7] = j * v + n * w + r * x;\n    dest[8] = g * y + k * z + o * A;\n    dest[9] = h * y + l * z + p * A;\n    dest[10] = i * y + m * z + q * A;\n    dest[11] = j * y + n * z + r * A;\n    return dest;\n  };\n\n  this.lookAt = function (eye, center, up, dest) {\n    var eyeX = eye[0],\n        eyeY = eye[1],\n        eyeZ = eye[2],\n        upX = up[0],\n        upY = up[1],\n        upZ = up[2],\n        centerX = center[0],\n        centerY = center[1],\n        centerZ = center[2];\n\n    if (eyeX == centerX && eyeY == centerY && eyeZ == centerZ) {\n      return this.identity(dest);\n    }\n\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, l;\n    z0 = eyeX - center[0];\n    z1 = eyeY - center[1];\n    z2 = eyeZ - center[2];\n    l = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= l;\n    z1 *= l;\n    z2 *= l;\n    x0 = upY * z2 - upZ * z1;\n    x1 = upZ * z0 - upX * z2;\n    x2 = upX * z1 - upY * z0;\n    l = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n    if (!l) {\n      x0 = 0;\n      x1 = 0;\n      x2 = 0;\n    } else {\n      l = 1 / l;\n      x0 *= l;\n      x1 *= l;\n      x2 *= l;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n    l = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n    if (!l) {\n      y0 = 0;\n      y1 = 0;\n      y2 = 0;\n    } else {\n      l = 1 / l;\n      y0 *= l;\n      y1 *= l;\n      y2 *= l;\n    }\n\n    dest[0] = x0;\n    dest[1] = y0;\n    dest[2] = z0;\n    dest[3] = 0;\n    dest[4] = x1;\n    dest[5] = y1;\n    dest[6] = z1;\n    dest[7] = 0;\n    dest[8] = x2;\n    dest[9] = y2;\n    dest[10] = z2;\n    dest[11] = 0;\n    dest[12] = -(x0 * eyeX + x1 * eyeY + x2 * eyeZ);\n    dest[13] = -(y0 * eyeX + y1 * eyeY + y2 * eyeZ);\n    dest[14] = -(z0 * eyeX + z1 * eyeY + z2 * eyeZ);\n    dest[15] = 1;\n    return dest;\n  };\n\n  this.perspective = function (fovy, aspect, near, far, dest) {\n    var t = near * Math.tan(fovy * Math.PI / 360);\n    var r = t * aspect;\n    var a = r * 2,\n        b = t * 2,\n        c = far - near;\n    dest[0] = near * 2 / a;\n    dest[1] = 0;\n    dest[2] = 0;\n    dest[3] = 0;\n    dest[4] = 0;\n    dest[5] = near * 2 / b;\n    dest[6] = 0;\n    dest[7] = 0;\n    dest[8] = 0;\n    dest[9] = 0;\n    dest[10] = -(far + near) / c;\n    dest[11] = -1;\n    dest[12] = 0;\n    dest[13] = 0;\n    dest[14] = -(far * near * 2) / c;\n    dest[15] = 0;\n    return dest;\n  };\n\n  this.ortho = function (left, right, top, bottom, near, far, dest) {\n    var h = right - left;\n    var v = top - bottom;\n    var d = far - near;\n    dest[0] = 2 / h;\n    dest[1] = 0;\n    dest[2] = 0;\n    dest[3] = 0;\n    dest[4] = 0;\n    dest[5] = 2 / v;\n    dest[6] = 0;\n    dest[7] = 0;\n    dest[8] = 0;\n    dest[9] = 0;\n    dest[10] = -2 / d;\n    dest[11] = 0;\n    dest[12] = -(left + right) / h;\n    dest[13] = -(top + bottom) / v;\n    dest[14] = -(far + near) / d;\n    dest[15] = 1;\n    return dest;\n  };\n\n  this.transpose = function (mat, dest) {\n    dest[0] = mat[0];\n    dest[1] = mat[4];\n    dest[2] = mat[8];\n    dest[3] = mat[12];\n    dest[4] = mat[1];\n    dest[5] = mat[5];\n    dest[6] = mat[9];\n    dest[7] = mat[13];\n    dest[8] = mat[2];\n    dest[9] = mat[6];\n    dest[10] = mat[10];\n    dest[11] = mat[14];\n    dest[12] = mat[3];\n    dest[13] = mat[7];\n    dest[14] = mat[11];\n    dest[15] = mat[15];\n    return dest;\n  };\n\n  this.inverse = function (mat, dest) {\n    var a = mat[0],\n        b = mat[1],\n        c = mat[2],\n        d = mat[3],\n        e = mat[4],\n        f = mat[5],\n        g = mat[6],\n        h = mat[7],\n        i = mat[8],\n        j = mat[9],\n        k = mat[10],\n        l = mat[11],\n        m = mat[12],\n        n = mat[13],\n        o = mat[14],\n        p = mat[15],\n        q = a * f - b * e,\n        r = a * g - c * e,\n        s = a * h - d * e,\n        t = b * g - c * f,\n        u = b * h - d * f,\n        v = c * h - d * g,\n        w = i * n - j * m,\n        x = i * o - k * m,\n        y = i * p - l * m,\n        z = j * o - k * n,\n        A = j * p - l * n,\n        B = k * p - l * o,\n        ivd = 1 / (q * B - r * A + s * z + t * y - u * x + v * w);\n    dest[0] = (f * B - g * A + h * z) * ivd;\n    dest[1] = (-b * B + c * A - d * z) * ivd;\n    dest[2] = (n * v - o * u + p * t) * ivd;\n    dest[3] = (-j * v + k * u - l * t) * ivd;\n    dest[4] = (-e * B + g * y - h * x) * ivd;\n    dest[5] = (a * B - c * y + d * x) * ivd;\n    dest[6] = (-m * v + o * s - p * r) * ivd;\n    dest[7] = (i * v - k * s + l * r) * ivd;\n    dest[8] = (e * A - f * y + h * w) * ivd;\n    dest[9] = (-a * A + b * y - d * w) * ivd;\n    dest[10] = (m * u - n * s + p * q) * ivd;\n    dest[11] = (-i * u + j * s - l * q) * ivd;\n    dest[12] = (-e * z + f * x - g * w) * ivd;\n    dest[13] = (a * z - b * x + c * w) * ivd;\n    dest[14] = (-m * t + n * r - o * q) * ivd;\n    dest[15] = (i * t - j * r + k * q) * ivd;\n    return dest;\n  };\n}\nfunction qtnIV() {\n  this.create = function () {\n    return new Float32Array(4);\n  };\n\n  this.identity = function (dest) {\n    dest[0] = 0;\n    dest[1] = 0;\n    dest[2] = 0;\n    dest[3] = 1;\n    return dest;\n  };\n\n  this.inverse = function (qtn, dest) {\n    dest[0] = -qtn[0];\n    dest[1] = -qtn[1];\n    dest[2] = -qtn[2];\n    dest[3] = qtn[3];\n    return dest;\n  };\n\n  this.normalize = function (dest) {\n    var x = dest[0],\n        y = dest[1],\n        z = dest[2],\n        w = dest[3];\n    var l = Math.sqrt(x * x + y * y + z * z + w * w);\n\n    if (l === 0) {\n      dest[0] = 0;\n      dest[1] = 0;\n      dest[2] = 0;\n      dest[3] = 0;\n    } else {\n      l = 1 / l;\n      dest[0] = x * l;\n      dest[1] = y * l;\n      dest[2] = z * l;\n      dest[3] = w * l;\n    }\n\n    return dest;\n  };\n\n  this.multiply = function (qtn1, qtn2, dest) {\n    var ax = qtn1[0],\n        ay = qtn1[1],\n        az = qtn1[2],\n        aw = qtn1[3];\n    var bx = qtn2[0],\n        by = qtn2[1],\n        bz = qtn2[2],\n        bw = qtn2[3];\n    dest[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dest[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dest[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dest[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dest;\n  };\n\n  this.rotate = function (angle, axis, dest) {\n    var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n\n    if (!sq) {\n      return null;\n    }\n\n    var a = axis[0],\n        b = axis[1],\n        c = axis[2];\n\n    if (sq != 1) {\n      sq = 1 / sq;\n      a *= sq;\n      b *= sq;\n      c *= sq;\n    }\n\n    var s = Math.sin(angle * 0.5);\n    dest[0] = a * s;\n    dest[1] = b * s;\n    dest[2] = c * s;\n    dest[3] = Math.cos(angle * 0.5);\n    return dest;\n  };\n\n  this.toVecIII = function (vec, qtn, dest) {\n    var qp = this.create();\n    var qq = this.create();\n    var qr = this.create();\n    this.inverse(qtn, qr);\n    qp[0] = vec[0];\n    qp[1] = vec[1];\n    qp[2] = vec[2];\n    this.multiply(qr, qp, qq);\n    this.multiply(qq, qtn, qr);\n    dest[0] = qr[0];\n    dest[1] = qr[1];\n    dest[2] = qr[2];\n    return dest;\n  };\n\n  this.toMatIV = function (qtn, dest) {\n    var x = qtn[0],\n        y = qtn[1],\n        z = qtn[2],\n        w = qtn[3];\n    var x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    var xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    var yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    var wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n    dest[0] = 1 - (yy + zz);\n    dest[1] = xy - wz;\n    dest[2] = xz + wy;\n    dest[3] = 0;\n    dest[4] = xy + wz;\n    dest[5] = 1 - (xx + zz);\n    dest[6] = yz - wx;\n    dest[7] = 0;\n    dest[8] = xz - wy;\n    dest[9] = yz + wx;\n    dest[10] = 1 - (xx + yy);\n    dest[11] = 0;\n    dest[12] = 0;\n    dest[13] = 0;\n    dest[14] = 0;\n    dest[15] = 1;\n    return dest;\n  };\n\n  this.slerp = function (qtn1, qtn2, time, dest) {\n    var ht = qtn1[0] * qtn2[0] + qtn1[1] * qtn2[1] + qtn1[2] * qtn2[2] + qtn1[3] * qtn2[3];\n    var hs = 1.0 - ht * ht;\n\n    if (hs <= 0.0) {\n      dest[0] = qtn1[0];\n      dest[1] = qtn1[1];\n      dest[2] = qtn1[2];\n      dest[3] = qtn1[3];\n    } else {\n      hs = Math.sqrt(hs);\n\n      if (Math.abs(hs) < 0.0001) {\n        dest[0] = qtn1[0] * 0.5 + qtn2[0] * 0.5;\n        dest[1] = qtn1[1] * 0.5 + qtn2[1] * 0.5;\n        dest[2] = qtn1[2] * 0.5 + qtn2[2] * 0.5;\n        dest[3] = qtn1[3] * 0.5 + qtn2[3] * 0.5;\n      } else {\n        var ph = Math.acos(ht);\n        var pt = ph * time;\n        var t0 = Math.sin(ph - pt) / hs;\n        var t1 = Math.sin(pt) / hs;\n        dest[0] = qtn1[0] * t0 + qtn2[0] * t1;\n        dest[1] = qtn1[1] * t0 + qtn2[1] * t1;\n        dest[2] = qtn1[2] * t0 + qtn2[2] * t1;\n        dest[3] = qtn1[3] * t0 + qtn2[3] * t1;\n      }\n    }\n\n    return dest;\n  };\n}\nfunction torus(row, column, irad, orad, color) {\n  var pos = new Array(),\n      nor = new Array(),\n      col = new Array(),\n      st = new Array(),\n      idx = new Array();\n\n  for (var i = 0; i <= row; i++) {\n    var r = Math.PI * 2 / row * i;\n    var rr = Math.cos(r);\n    var ry = Math.sin(r);\n\n    for (var ii = 0; ii <= column; ii++) {\n      var tr = Math.PI * 2 / column * ii;\n      var tx = (rr * irad + orad) * Math.cos(tr);\n      var ty = ry * irad;\n      var tz = (rr * irad + orad) * Math.sin(tr);\n      var rx = rr * Math.cos(tr);\n      var rz = rr * Math.sin(tr);\n\n      if (color) {\n        var tc = color;\n      } else {\n        tc = hsva(360 / column * ii, 1, 1, 1);\n      }\n\n      var rs = 1 / column * ii;\n      var rt = 1 / row * i + 0.5;\n\n      if (rt > 1.0) {\n        rt -= 1.0;\n      }\n\n      rt = 1.0 - rt;\n      pos.push(tx, ty, tz);\n      nor.push(rx, ry, rz);\n      col.push(tc[0], tc[1], tc[2], tc[3]);\n      st.push(rs, rt);\n    }\n  }\n\n  for (i = 0; i < row; i++) {\n    for (ii = 0; ii < column; ii++) {\n      r = (column + 1) * i + ii;\n      idx.push(r, r + column + 1, r + 1);\n      idx.push(r + column + 1, r + column + 2, r + 1);\n    }\n  }\n\n  return {\n    p: pos,\n    n: nor,\n    c: col,\n    t: st,\n    i: idx\n  };\n}\nfunction sphere(row, column, rad, color) {\n  var pos = new Array(),\n      nor = new Array(),\n      col = new Array(),\n      st = new Array(),\n      idx = new Array();\n\n  for (var i = 0; i <= row; i++) {\n    var r = Math.PI / row * i;\n    var ry = Math.cos(r);\n    var rr = Math.sin(r);\n\n    for (var ii = 0; ii <= column; ii++) {\n      var tr = Math.PI * 2 / column * ii;\n      var tx = rr * rad * Math.cos(tr);\n      var ty = ry * rad;\n      var tz = rr * rad * Math.sin(tr);\n      var rx = rr * Math.cos(tr);\n      var rz = rr * Math.sin(tr);\n\n      if (color) {\n        var tc = color;\n      } else {\n        tc = hsva(360 / row * i, 1, 1, 1);\n      }\n\n      pos.push(tx, ty, tz);\n      nor.push(rx, ry, rz);\n      col.push(tc[0], tc[1], tc[2], tc[3]);\n      st.push(1 - 1 / column * ii, 1 / row * i);\n    }\n  }\n\n  r = 0;\n\n  for (i = 0; i < row; i++) {\n    for (ii = 0; ii < column; ii++) {\n      r = (column + 1) * i + ii;\n      idx.push(r, r + 1, r + column + 2);\n      idx.push(r, r + column + 2, r + column + 1);\n    }\n  }\n\n  return {\n    p: pos,\n    n: nor,\n    c: col,\n    t: st,\n    i: idx\n  };\n}\nfunction cube(side, color) {\n  var hs = side * 0.5;\n  var pos = [-hs, -hs, hs, hs, -hs, hs, hs, hs, hs, -hs, hs, hs, -hs, -hs, -hs, -hs, hs, -hs, hs, hs, -hs, hs, -hs, -hs, -hs, hs, -hs, -hs, hs, hs, hs, hs, hs, hs, hs, -hs, -hs, -hs, -hs, hs, -hs, -hs, hs, -hs, hs, -hs, -hs, hs, hs, -hs, -hs, hs, hs, -hs, hs, hs, hs, hs, -hs, hs, -hs, -hs, -hs, -hs, -hs, hs, -hs, hs, hs, -hs, hs, -hs];\n  var nor = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];\n  var col = new Array();\n\n  for (var i = 0; i < pos.length / 3; i++) {\n    if (color) {\n      var tc = color;\n    } else {\n      tc = hsva(360 / pos.length / 3 * i, 1, 1, 1);\n    }\n\n    col.push(tc[0], tc[1], tc[2], tc[3]);\n  }\n\n  var st = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];\n  var idx = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n  return {\n    p: pos,\n    n: nor,\n    c: col,\n    t: st,\n    i: idx\n  };\n}\nfunction hsva(h, s, v, a) {\n  if (s > 1 || v > 1 || a > 1) {\n    return;\n  }\n\n  var th = h % 360;\n  var i = Math.floor(th / 60);\n  var f = th / 60 - i;\n  var m = v * (1 - s);\n  var n = v * (1 - s * f);\n  var k = v * (1 - s * (1 - f));\n  var color = new Array();\n\n  if (!s > 0 && !s < 0) {\n    color.push(v, v, v, a);\n  } else {\n    var r = new Array(v, n, m, m, k, v);\n    var g = new Array(k, v, v, n, m, m);\n    var b = new Array(m, m, k, v, v, n);\n    color.push(r[i], g[i], b[i], a);\n  }\n\n  return color;\n}\n\n//# sourceURL=webpack:///./src/assets/js/lib/minMatrixb.js?");

/***/ }),

/***/ "./src/assets/js/script.js":
/*!*********************************!*\
  !*** ./src/assets/js/script.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_minMatrixb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/minMatrixb.js */ \"./src/assets/js/lib/minMatrixb.js\");\n\n/* ---------------------------------------------------------------------------\n  VARIABLE\n---------------------------------------------------------------------------- */\n\nvar gl;\nvar canvas;\nvar canvasWidth;\nvar canvasHeight;\nvar program;\nvar shaderData = [];\nvar aData = [];\nvar aLocation = [];\nvar aStride = [];\nvar uData = [];\nvar uLocation = [];\nvar position;\nvar color;\nvar normal;\nvar vertexPosition = [];\nvar vertexColor = [];\nvar vertexNormal = [];\nvar vertexIndex = [];\nvar faceNormal = [];\nvar indexLength;\nvar VBO;\nvar IBO;\nvar statusRun;\nvar timeStart;\nvar timeNow;\nvar m4;\nvar matrixM;\nvar matrixV;\nvar matrixP;\nvar matrixVP;\nvar matrixMVP;\nvar cameraDistance = 12.5;\nvar cameraPosition = [0.0, 0.0, cameraDistance];\nvar centerPosition = [0.0, 0.0, 0.0];\nvar cameraUpDirection = [0.0, 1.0, 0.0];\nvar dCameraPosition = [0.0, 0.0, cameraDistance];\nvar dCenterPosition = [0.0, 0.0, 0.0];\nvar dCameraUpDirection = [0.0, 1.0, 0.0];\nvar cameraRotateX = 0.0;\nvar cameraRotateY = 0.0;\nvar cameraScale = 0.0;\nvar statusClick = false;\nvar positionStart = [];\nvar positionEnd = [];\nvar qt4 = new _lib_minMatrixb_js__WEBPACK_IMPORTED_MODULE_0__[\"qtnIV\"]();\nvar qt = qt4.identity(qt4.create());\nvar qtx = qt4.identity(qt4.create());\nvar qty = qt4.identity(qt4.create());\n\n(function () {\n  window.addEventListener('load', function () {\n    canvas = document.getElementById('webgl_canvas');\n    gl = canvas.getContext('webgl');\n    window.addEventListener('keydown', function (event) {\n      statusRun = event.key !== 'Escape';\n    }, false);\n    canvas.width = canvasWidth = window.innerWidth;\n    canvas.height = canvasHeight = window.innerHeight;\n    canvas.addEventListener('mousedown', mouseInteractionStart, false);\n    canvas.addEventListener('mousemove', mouseInteractionMove, false);\n    canvas.addEventListener('mouseup', mouseInteractionEnd, false);\n    canvas.addEventListener('wheel', wheelScroll, false);\n    load();\n  }, false);\n\n  var load = function load() {\n    shaderData = loadNewShader('./assets/shader/main.vert', './assets/shader/main.frag');\n    program = createNewProgram(shaderData[0], shaderData[1]);\n    aData = [['aPosition', 'aColor', 'aNormal'], [3, 4, 3]];\n    getNewLocation(program, 'a', aData, aLocation, aStride);\n    uData = [['matrixMVP'], ['matrix4fv']];\n    getNewLocation(program, 'u', uData, uLocation);\n    initialize();\n  };\n\n  var initialize = function initialize() {\n    vertexPosition.push(0.0, 1.0, 0.0);\n    vertexPosition.push(0.0, -1.0, 0.0);\n    vertexColor.push(1.0, 1.0, 1.0, 1.0);\n    vertexColor.push(1.0, 1.0, 1.0, 1.0);\n\n    (function () {\n      var SPLIT = 16;\n      var DEGREE = 360 / SPLIT;\n      var RADIAN = DEGREE * Math.PI / 180;\n\n      for (var i = 0; i < SPLIT; ++i) {\n        var r = RADIAN * i;\n        var s = Math.sin(r);\n        var c = Math.cos(r);\n        vertexPosition.push(s, 1.0, c);\n        vertexColor.push(0.25, 1.0, 1.0, 1.0);\n\n        if (i === SPLIT - 1) {\n          vertexIndex.push(0, SPLIT + 1, 2);\n        } else {\n          vertexIndex.push(0, i + 2, i + 3);\n        }\n      }\n\n      for (var j = 0; j < SPLIT; ++j) {\n        var _r = RADIAN * j;\n\n        var _s = Math.sin(_r);\n\n        var _c = Math.cos(_r);\n\n        var iN = j + SPLIT + 2;\n        vertexPosition.push(_s, -1.0, _c);\n        vertexColor.push(0.25, 1.0, 1.0, 1.0);\n\n        if (j === 0) {\n          vertexIndex.push(1, iN, iN + SPLIT - 1);\n        } else {\n          vertexIndex.push(1, iN, iN - 1);\n        }\n      }\n\n      for (var k = 0; k < SPLIT; ++k) {\n        var _iN = k + 2;\n\n        if (k === 0) {\n          vertexIndex.push(_iN, SPLIT * 2 + 1, SPLIT + 2);\n        } else {\n          vertexIndex.push(_iN, _iN + SPLIT - 1, _iN + SPLIT);\n        }\n      }\n\n      for (var _j = 0; _j < SPLIT; ++_j) {\n        var _iN2 = _j + 2;\n\n        if (_j === SPLIT - 1) {\n          vertexIndex.push(_iN2, _iN2 + SPLIT, 2);\n        } else {\n          vertexIndex.push(_iN2, _iN2 + SPLIT, _iN2 + 1);\n        }\n      }\n    })();\n\n    (function () {\n      for (var i = 0; i < vertexIndex.length / 3; i++) {\n        var faceN = [];\n        var positionBase = getPosition(vertexPosition, vertexIndex[0 + 3 * i], vertexIndex[1 + 3 * i], vertexIndex[2 + 3 * i]);\n        var _positionStart = positionBase[0];\n        var positionMiddle = positionBase[1];\n        var _positionEnd = positionBase[2];\n        faceN = calculateNormalVector(calculateVectorDirection(_positionStart, positionMiddle), calculateVectorDirection(_positionEnd, positionMiddle));\n        faceN = normalizeVector(faceN, calculateVectorSize(faceN));\n        faceNormal.push(faceN[0]);\n        faceNormal.push(faceN[1]);\n        faceNormal.push(faceN[2]);\n      }\n\n      ;\n    })();\n\n    (function () {\n      for (var h = 0; h < vertexPosition.length / 3; h++) {\n        var vertexN = [0, 0, 0];\n\n        for (var i = 0; i < vertexIndex.length; i++) {\n          if (vertexIndex[i] == h) {\n            if (i % 3 == 0) {\n              vertexN[0] += faceNormal[i];\n              vertexN[1] += faceNormal[i + 1];\n              vertexN[2] += faceNormal[i + 2];\n            } else if (i % 3 == 1) {\n              vertexN[0] += faceNormal[i - 1];\n              vertexN[1] += faceNormal[i];\n              vertexN[2] += faceNormal[i + 1];\n            } else {\n              vertexN[0] += faceNormal[i - 2];\n              vertexN[1] += faceNormal[i - 1];\n              vertexN[2] += faceNormal[i];\n            }\n          }\n\n          ;\n        }\n\n        ;\n        vertexN = normalizeVector(vertexN, calculateVectorSize(vertexN));\n        vertexNormal.push(vertexN[0] * -1);\n        vertexNormal.push(vertexN[1] * -1);\n        vertexNormal.push(vertexN[2] * -1);\n      }\n\n      ;\n    })();\n\n    position = createNewVbo(vertexPosition);\n    color = createNewVbo(vertexColor);\n    normal = createNewVbo(vertexNormal);\n    VBO = [position, color, normal];\n    IBO = createNewIbo(vertexIndex);\n    indexLength = vertexIndex.length;\n    m4 = new _lib_minMatrixb_js__WEBPACK_IMPORTED_MODULE_0__[\"matIV\"]();\n    matrixM = m4.identity(m4.create());\n    matrixV = m4.identity(m4.create());\n    matrixP = m4.identity(m4.create());\n    matrixVP = m4.identity(m4.create());\n    matrixMVP = m4.identity(m4.create());\n    gl.enable(gl.DEPTH_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    timeStart = Date.now();\n    timeNow = 0;\n    render();\n  };\n\n  var render = function render() {\n    setNewAttribute(VBO, aLocation, aStride);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IBO);\n    canvas.width = canvasWidth = window.innerWidth;\n    canvas.height = canvasHeight = window.innerHeight;\n    gl.viewport(0, 0, canvasWidth, canvasHeight);\n    gl.clearColor(0, 0, 0, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    var cameraAspect = canvasWidth / canvasHeight;\n    cameraUpdate();\n    m4.lookAt(cameraPosition, centerPosition, cameraUpDirection, matrixV);\n    m4.perspective(45, cameraAspect, 0.1, cameraDistance * 2.0, matrixP);\n    m4.multiply(matrixP, matrixV, matrixVP);\n    timeNow = (Date.now() - timeStart) / 1000;\n    m4.identity(matrixM); // m4.translate(matrixM, [0.0, -1.0, 0.0], matrixM);\n    // m4.rotate(matrixM, timeNow * 2.0, [0.0, -1.0, -1.0], matrixM);\n\n    m4.multiply(matrixVP, matrixM, matrixMVP);\n    gl.uniformMatrix4fv(uLocation[0], false, matrixMVP);\n    gl.drawElements(gl.TRIANGLES, indexLength, gl.UNSIGNED_SHORT, 0);\n    requestAnimationFrame(render);\n  };\n})();\n/* ---------------------------------------------------------------------------\n  FUNCTION loadNewShader\n---------------------------------------------------------------------------- */\n\n\nvar loadNewShader = function loadNewShader(vertexPath, fragmentPath) {\n  var x = new XMLHttpRequest();\n  var shaderData = [];\n  var sourceVertex;\n  var shaderVertex = gl.createShader(gl.VERTEX_SHADER);\n  var sourceFragment;\n  var shaderFragment = gl.createShader(gl.FRAGMENT_SHADER);\n  x.open('GET', vertexPath, false);\n\n  x.onload = function () {\n    sourceVertex = x.responseText;\n  };\n\n  x.send();\n  x.open('GET', fragmentPath, false);\n\n  x.onload = function () {\n    sourceFragment = x.responseText;\n  };\n\n  x.send();\n  gl.shaderSource(shaderVertex, sourceVertex);\n  gl.compileShader(shaderVertex);\n  shaderData.push(shaderVertex);\n  gl.shaderSource(shaderFragment, sourceFragment);\n  gl.compileShader(shaderFragment);\n  shaderData.push(shaderFragment);\n\n  if (gl.getShaderParameter(shaderVertex, gl.COMPILE_STATUS) && gl.getShaderParameter(shaderFragment, gl.COMPILE_STATUS)) {\n    return shaderData;\n  } else {\n    console.log(gl.getShaderInfoLog(shaderVertex));\n    console.log(gl.getShaderInfoLog(shaderFragment));\n  }\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION createNewProgram\n---------------------------------------------------------------------------- */\n\n\nvar createNewProgram = function createNewProgram(vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    gl.useProgram(program);\n    return program;\n  } else {\n    return null;\n  }\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION getNewLocation\n---------------------------------------------------------------------------- */\n\n\nvar getNewLocation = function getNewLocation(program, type, dataArray, locationArray, strideArray) {\n  switch (type) {\n    case 'a':\n      for (var i = 0; i < dataArray[0].length; ++i) {\n        locationArray[i] = gl.getAttribLocation(program, dataArray[0][i]);\n        strideArray[i] = dataArray[1][i];\n      }\n\n      break;\n\n    case 'u':\n      for (var _i = 0; _i < dataArray[0].length; ++_i) {\n        locationArray[_i] = gl.getUniformLocation(program, dataArray[0][_i]);\n      }\n\n      break;\n  }\n};\n/* ---------------------------------------------------------------------------\n    FUNCTION setNewAttribute\n  ---------------------------------------------------------------------------- */\n\n\nvar setNewAttribute = function setNewAttribute(vbo, locationArray, strideArray) {\n  for (var i in vbo) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo[i]);\n    gl.enableVertexAttribArray(locationArray[i]);\n    gl.vertexAttribPointer(locationArray[i], strideArray[i], gl.FLOAT, false, 0, 0);\n  }\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION createNewVbo\n---------------------------------------------------------------------------- */\n\n\nvar createNewVbo = function createNewVbo(data) {\n  var vbo = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  return vbo;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION createNewIbo\n---------------------------------------------------------------------------- */\n\n\nvar createNewIbo = function createNewIbo(data) {\n  var ibo = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  return ibo;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION getPosition\n---------------------------------------------------------------------------- */\n\n\nvar getPosition = function getPosition(positionArray, positionNumber01, positionNumber02, positionNumber03) {\n  var position = [];\n  var position01 = [];\n  var position02 = [];\n  var position03 = [];\n\n  for (var i = 0; i < 3; i++) {\n    position01.push(positionArray[positionNumber01 * 3 + i]);\n  }\n\n  for (var j = 0; j < 3; j++) {\n    position02.push(positionArray[positionNumber02 * 3 + j]);\n  }\n\n  for (var k = 0; k < 3; k++) {\n    position03.push(positionArray[positionNumber03 * 3 + k]);\n  }\n\n  position.push(position01);\n  position.push(position02);\n  position.push(position03);\n  return position;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION calculateVectorDirection\n---------------------------------------------------------------------------- */\n\n\nvar calculateVectorDirection = function calculateVectorDirection(position01, position02) {\n  var vectorDirection = [];\n  vectorDirection = [position02[0] - position01[0], position02[1] - position01[1], position02[2] - position01[2]];\n  return vectorDirection;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION calculateVectorSize\n---------------------------------------------------------------------------- */\n\n\nvar calculateVectorSize = function calculateVectorSize(vector) {\n  var vectorSize;\n  vectorSize = Math.pow(vector[0], 2) + Math.pow(vector[1], 2) + Math.pow(vector[2], 2);\n  vectorSize = Math.sqrt(vectorSize);\n  return vectorSize;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION calculateNormalVector\n---------------------------------------------------------------------------- */\n\n\nvar calculateNormalVector = function calculateNormalVector(vector01, vector02) {\n  var normalVector = [];\n  normalVector = [vector01[1] * vector02[2] - vector01[2] * vector02[1], vector01[2] * vector02[0] - vector01[0] * vector02[2], vector01[0] * vector02[1] - vector01[1] * vector02[0]];\n  return normalVector;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION normalizeVector\n---------------------------------------------------------------------------- */\n\n\nvar normalizeVector = function normalizeVector(vectorDirection, vectorSize) {\n  var normalizeVector = [];\n  normalizeVector = [vectorDirection[0] / vectorSize, vectorDirection[1] / vectorSize, vectorDirection[2] / vectorSize];\n  return normalizeVector;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION mouseInteractionStart\n---------------------------------------------------------------------------- */\n\n\nvar mouseInteractionStart = function mouseInteractionStart(eve) {\n  statusClick = true;\n  positionStart = [eve.pageX, eve.pageY];\n  eve.preventDefault();\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION mouseInteractionMove\n---------------------------------------------------------------------------- */\n\n\nvar mouseInteractionMove = function mouseInteractionMove(eve) {\n  if (!statusClick) {\n    return;\n  }\n\n  var w = canvas.width;\n  var h = canvas.height;\n  var s = 1.0 / Math.min(w, h);\n  positionEnd = [eve.pageX - positionStart[0], eve.pageY - positionStart[1]];\n  positionStart = [eve.pageX, eve.pageY];\n\n  switch (eve.buttons) {\n    case 1:\n      cameraRotateX += positionEnd[0] * s;\n      cameraRotateY += positionEnd[1] * s;\n      cameraRotateX = cameraRotateX % 1.0;\n      cameraRotateY = Math.min(Math.max(cameraRotateY % 1.0, -0.25), 0.25);\n      break;\n  }\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION mouseInteractionEnd\n---------------------------------------------------------------------------- */\n\n\nvar mouseInteractionEnd = function mouseInteractionEnd() {\n  statusClick = false;\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION wheelScroll\n---------------------------------------------------------------------------- */\n\n\nvar wheelScroll = function wheelScroll(eve) {\n  var w = eve.wheelDelta;\n\n  if (w > 0) {\n    cameraScale = 0.8;\n  } else if (w < 0) {\n    cameraScale = -0.8;\n  }\n};\n/* ---------------------------------------------------------------------------\n  FUNCTION cameraUpdate\n---------------------------------------------------------------------------- */\n\n\nvar cameraUpdate = function cameraUpdate() {\n  var v = [1.0, 0.0, 0.0];\n  cameraScale *= 0.75;\n  cameraDistance += cameraScale;\n  cameraDistance = Math.min(Math.max(cameraDistance, 5.0), 20.0);\n  dCameraPosition[2] = cameraDistance;\n  qt4.identity(qt);\n  qt4.identity(qtx);\n  qt4.identity(qty);\n  qt4.rotate(cameraRotateX * Math.PI * 2, [0.0, 1.0, 0.0], qtx);\n  qt4.toVecIII(v, qtx, v);\n  qt4.rotate(cameraRotateY * Math.PI * 2, v, qty);\n  qt4.multiply(qtx, qty, qt);\n  qt4.toVecIII(dCameraPosition, qt, cameraPosition);\n  qt4.toVecIII(dCameraUpDirection, qt, cameraUpDirection);\n};\n\n//# sourceURL=webpack:///./src/assets/js/script.js?");

/***/ })

/******/ });